==============================================================================================================================
###) Error Boundary::->Error Boundaries basically provide some sort of boundaries or checks on errors,They are React components that are used to handle JavaScript errors in their child component tree.
In React, "error boundaries" are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire React application. They are a feature introduced in React 16 to improve the error-handling experience in applications.

   How Error Boundaries Work::->  To define an error boundary in your React application, you create a component that extends React.Component and implements either or both of the lifecycle methods static getDerivedStateFromError(error) or componentDidCatch(error, errorInfo).

static getDerivedStateFromError(error):- This method is used to update state when an error is thrown by a descendant component. It allows the component to render a fallback UI after an error occurs. It only say there is error or not.

componentDidCatch(error, errorInfo): This method is called after an error has been thrown by a descendant component. It say there is error or not and also send the info of error.
It receives two parameters:
error: The error that was thrown.
errorInfo: An object with a componentStack key containing information about which component threw the error.
Usage::: You wrap components that you suspect might throw errors in your application with the error boundary component. This way, if any error occurs within that subtree of components, the error boundary will catch it and handle it gracefully.


Key Points to Remember::::-->
Propagation:: Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.

Single Responsibility:: Each error boundary covers its own subtree, and they do not catch errors for the whole application. You can have multiple error boundaries in a single application.

Class Components:: Error boundaries are regular React components defined as classes. They only catch errors in components below them in the tree, not above.

Function Components:: Starting from React 16.6, you can also use error boundaries with function components using the useErrorBoundary hook from libraries like react-error-boundary.
note::- Error boundries help in which components have error only effect them and rest of the whole app will not crash.

1)static getDrivedStateFromErro(error) {
return {hasError:true};
}    //will tell only there is error or not ,it will not give the info about error.

2) componentDidCatch(error,errorInfo) {
 logErrorToMyService(error,errorInfo);
}   //will tell the error and as well as will give the error info.

===============================================================================================================================
===============================================================================================================================
###) Explain the purpose of Higher-Order Components (HOCs) in React. Give an example of when you would use one. ?
:::::When you pass a component to a function and it returns a new component, itâ€™s called a higher-order component (HOC). 
Higher-Order Components (HOCs) in React are a design pattern used for reusing component logic. They are functions that accept a component as an argument and return a new component with enhanced functionality. The main purpose of HOCs is to share common functionality between components without repeating code.

Purpose of HOCs/Why we use:::: 1) Code Reuse: HOCs allow you to extract common logic from components and reuse it across different parts of your application. This promotes cleaner and more maintainable code.
2)Props Manipulation: HOCs can manipulate props or inject additional props into components before rendering, which can be useful for providing data or behaviors to components based on certain conditions.

Example of when to use a HOC:::::: Consider a scenario where you have multiple components in your React application that need to fetch data from an API endpoint. Instead of duplicating the data fetching logic in each component, you can create a HOC to handle the data fetching and then pass the fetched data as props to the components.

A) HOC component ---
import React,{Component} from "react";


const AreaOFRatings = (SUBCOMP) =>{

    class AreaOFRating extends Component {
        render(){
            return (
                <SUBCOMP hocsub="JAVASCRIPT"></SUBCOMP>
            )
        }
    }
    return AreaOFRating;
}

export default AreaOFRatings;


B)  normal component which wil pass to HOC componet:
import React from "react";
import AreaOFRatings from "./HOC";
class User1 extends React.Component {
    state={
        rating:0
    }

    RatingInc = ()=>{
        this.setState({rating:this.state.rating+1})
    }
    render() {

        return (
            <div>
                <h2 onMouseOver={this.RatingInc}>User1 Rank: {this.state.rating},{this.props.hocsub}</h2>
            </div>
        )
    }
}
export default AreaOFRatings(User1);

C) another  normal component which wil pass to HOC componet:
import React from "react";
import AreaOFRatings from "./HOC";
class User2 extends React.Component {
    state={
        rating:0
    }

    RatingInc = ()=>{
        this.setState({rating:this.state.rating+1})
    }
    render() {

        return (
            <div>
                <h2 onMouseOver={this.RatingInc}>User2 Rank: {this.state.rating}, {this.props.hocsub}</h2>
            </div>
        )
    }
}
export default AreaOFRatings(User2);

D) Main component APP :
import './App.css';
import User1 from './Components/User1.jsx';
import User2 from './Components/USer2.jsx';
function App() {
  return (
    <>
       <h5>HOC COMPONENTS</h5>
       <hr />
      <User1></User1>
      <User2></User2>
    </>
  );
}

export default App;

===============================================================================================================================
===============================================================================================================================
###) What are hooks in React? How do they differ from class components?
    Hooks were added to React in version 16.8.
Hooks in React are functions that allow you to use state and other React features in functional components instead of class components. 
    Hooks in React differ from class components in several key ways::::

1.Function vs Class Syntax:: Hooks allow you to use state and other React features directly in functional components, whereas class components use ES6 class syntax to define a component with its state and lifecycle methods.
2.State Management:: In function components with hooks, you use the useState hook to add state to a functional component, whereas in class components, state is declared using this.state and modified using this.setState.
3. Lifecycle Methods:: Hooks provide lifecycle functionalities (like useEffect for handling side effects) directly within function components. Class components use lifecycle methods (componentDidMount, componentDidUpdate, etc.) for similar purposes.
4.Readability and Maintainability:: Hooks generally lead to more concise and readable code compared to class components, especially for simpler components that don't require the full power of class-based architecture.
5. Ease of Testing:: Functional components with hooks are easier to test because you can test them like regular functions without needing to deal with the complexities of class instance methods and lifecycle methods.

Types of hooks in reactjs:-

1) useState():- Allows functional components to manage local state.
ex:- const[count setCount] = useState(0);

2) useReducer():- Alternative to useState for more complex state management.
ex:- const [state, dispatch] = useReducer(reducer, initialState);

3)useEffect():-Allows functional components to perform side effects.
Some examples of side effects are: fetching data, directly updating the DOM, and timers.
useEffect accepts two arguments. The second argument is optional.
useEffect is Asynchronous.
useEffect always run after DOM printed.
useEffect(<function>, <dependency>)
Similar to componentDidMount, componentDidUpdate, and componentWillUnmount in class components.
Ex: useEffect(() => {
  // Effect code
  return () => {
    // Cleanup code
  };
}, [dependencies]);

4) useContext():- Allows functional components to consume context. (It is solution of Props drilling in react components.)
Ex:-const value = useContext(MyContext);

5) useRef() :- Returns a mutable ref object whose .current property is initialized to the passed argument.
Useful for accessing DOM nodes or storing mutable values.
Ex:- const inputRef = useRef(initialValue);

6) useMemo():- Memoizes a value computation and returns the memoized value.  Useful for optimizing performance by caching expensive calculations.
Ex:- const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

7) useCallback():- Returns a memoized callback. Useful for optimizing performance by caching callbacks that depend on props or state.
Ex:-const memoizedCallback = useCallback(() => {
  // Callback function
}, [dependencies]);
 
8) useLayoutEffect():- useLayoutEffect hooks works same as useEffect hooks but the diffrence is- useEffect runs after the DOM is printed on the browser. UseLayoutEffect runs Before the DOM is printed on the browser.
Whenever we want to run code before the DOM is printed like we want to measure Height, Width or Anything related to layout we can use useLayoutEffect.
useLayoutEffect runs synchronously.
The most common use case of useLayoutEffect is to get the dimension of the layout. That's why it's name is useLayoutEffect.
useLayoutEffect always run before useEffect. (when we use both in out react components.).
React calculate this component -->then> React prints all elements -->then> useEffect.
EX:-      import React,{useState,useEffect,useLayoutEffect,useRef} from "react";

const LayoutHook = () =>{
const [toggle,setToggle] = useState(false);
const textRef = useRef();

useEffect(()=>{
    console.log("useEffect call !");
    if(textRef.current != null) {
        const dimansion = textRef.current.getBoundingClientRect();
        textRef.current.style.paddingTop = `${dimansion?.height}px`;
        console.log(dimansion);
    } 
},[toggle]);

// uselayout example
useLayoutEffect(()=>{
    console.log("useLayoutEffect call !");
    if(textRef.current != null) {
        const dimansion = textRef.current.getBoundingClientRect();
        textRef.current.style.paddingTop = `${dimansion?.height}px`;
        console.log(dimansion);
    }
},[toggle]);

const togleFun = () =>{
    setToggle(!toggle);
}

return (<>
<button onClick={togleFun}>Toggle</button>
   { toggle && <h4 ref={textRef}>Code base</h4> } 
</>);
}
export default LayoutHook;
===============================================================================================================================
===============================================================================================================================
###) Describe the significance of React's Context API. When would you prefer using Context over props drilling?
  React's Context API is significant because it provides a way to share data between components without having to explicitly pass props through every level of the component tree. 
 It solves the problem of "props drilling," where intermediate components that don't need the data pass it down through props just to reach deeply nested components that do need it.

Significance of React's Context API:::
1) Avoids Props Drilling:- Context API allows you to pass data through the component tree without having to pass props manually at every level. his simplifies the code and makes it more maintainable by reducing the number of props passed through intermediate components.

2) Global State Management:-It's commonly used for managing global state such as user authentication, theme, localization preferences, etc., where multiple components across the application need access to this shared state.

3)Simplifies Component Composition:- Context provides a cleaner way to compose components by separating the concern of passing data from parent to child components explicitly.

4)Performance Considerations:-While Context can be convenient, excessive use can lead to unnecessary re-renders of components consuming context, so it's important to use it judiciously and consider the performance implications.

When to Use Context API Over Props Drilling::: 
1) Deeply Nested Components:: When you have deeply nested components that need access to certain data or functions, using Context avoids the overhead of passing props through many intermediate components.
2)Global State Requirements:: For managing global state that is accessed by many components across different parts of your application. Examples include user authentication status, user preferences, theme settings, etc.

Example for Context API :---
// Step 1: Create a context
import React, { createContext, useState, useContext } from 'react';

const ThemeContext = createContext(); // Create a context object

// Step 2: Create a provider component
const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Step 3: Use the context in consuming components
const App = () => {
  return (
    <ThemeProvider>
      <div>
        <Header />
        <Main />
        <Footer />
      </div>
    </ThemeProvider>
  );
};

const Header = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    <header style={{ background: theme === 'light' ? '#f0f0f0' : '#333', color: theme === 'light' ? '#333' : '#f0f0f0' }}>
      <h1>Header</h1>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </header>
  );
};

const Main = () => {
  return (
    <main>
      <Content />
    </main>
  );
};

const Content = () => {
  const { theme } = useContext(ThemeContext);
  return (
    <section style={{ background: theme === 'light' ? '#f9f9f9' : '#666', color: theme === 'light' ? '#333' : '#f0f0f0' }}>
      <h2>Content Section</h2>
      <p>This is the main content area.</p>
    </section>
  );
};

const Footer = () => {
  const { theme } = useContext(ThemeContext);
  return (
    <footer style={{ background: theme === 'light' ? '#f0f0f0' : '#333', color: theme === 'light' ? '#333' : '#f0f0f0' }}>
      <p>Footer</p>
    </footer>
  );
};
export default App;


==============================================================================================================================
==============================================================================================================================
###) Compare React's server-side rendering (SSR) vs. client-side rendering (CSR). When would you choose one over the other in a project?

###) How does React handle state management? Discuss the use of Redux with React and explain the benefits of using Redux in a large application.

###) What are React Fragments? How and why would you use them in your components?

###) Explain the concept of reconciliation in React. What strategies can you employ to optimize reconciliation performance?

###) Discuss the differences between controlled and uncontrolled components in React forms. When would you use each type?

###) How does React handle lifecycle methods in functional components? What are the equivalents of componentDidMount and componentDidUpdate in functional components with hooks?

###) Describe the role of React Router in a React application. How would you implement nested routing using React Router v5 or v6?

###) What are the benefits of using TypeScript with React? How does TypeScript enhance the development process in a React project?

###) Explain the concept of virtual DOM in React. How does it contribute to React's performance compared to traditional DOM manipulation?

###) How do you optimize a React application for performance? Discuss some tools and techniques you've used to measure and improve performance in your previous projects.

###) What are the key differences between React 16 and React 17? How has the React ecosystem evolved between these versions?

###) Discuss the importance of code splitting in a React application. How would you implement code splitting using React.lazy() and Suspense?
###) How many hooks in react Explain it ?
